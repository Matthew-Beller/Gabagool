from __future__ import unicode_literals
from __future__ import print_function

import srt
import os
import datetime
import tempfile
import subprocess
import math

def saveAsIndividualClips(subtitle_source, output_directory, buffer_seconds_start, buffer_seconds_end):
   """
   Saves all entries in a searched subtitle file into individual .mp4 files.\n
   Clips are saved within a single folder within the output directory.\n
   Saved video clips are ended with two numbers:
   * The first number indicates the clip number in relation to other clips from the same source file.
   * The second number indicates the clip number in relation to the total number of clips generated, regardless of source.

   subtitle_source must be a subtitle file generated by find_subtitle_matches_single or find_subtitle_matches_batch functions.\n
   buffer_seconds_start and buffer_seconds_end are buffers of time added to extend clip before and after subtitle entry time frame.
   """

   video_number = 1
   source_name = os.path.splitext(os.path.basename(subtitle_source))[0]
   os.chdir(output_directory)

   new_output_directory = str(os.path.join(output_directory, source_name + "_videos"))

   duplicate_count = 0
   while(os.path.isdir(new_output_directory)):
         duplicate_count +=1 
         new_output_directory = str(os.path.join(output_directory, source_name + "_videos(" + str(duplicate_count) + ")"))

   os.mkdir(new_output_directory)
   os.chdir(new_output_directory)

   # opens searched subtitle file and adds buffer to beginning and end of all entries
   with open(subtitle_source, encoding='utf-8') as file:
      subtitle_generator = srt.parse(file)

      subtitles_list = list(subtitle_generator)
      buffer_start_datetime = datetime.timedelta(seconds=buffer_seconds_start)
      buffer_end_datetime = datetime.timedelta(seconds=buffer_seconds_end)

      for entry in subtitles_list:
         # stops addition of buffer from extending clip beyond beginning of the source video file
         if(entry.start > buffer_start_datetime):
            entry.start = entry.start - buffer_start_datetime
         else:
            # necessary due to the nature of datetime.timedelta datatype
            entry.start -= entry.start
         entry.end = entry.end + buffer_end_datetime
   total_clips = len(subtitles_list)

   max_numbers_places = int(math.log10(total_clips))+1
   previous_entry_proprietary = None

   # saves video clips individually into ouput folder
   for entry in subtitles_list:
      if(previous_entry_proprietary is not None and str(previous_entry_proprietary) == str(entry.proprietary)):
         same_file_counter += 1
      else:
         same_file_counter = 1

      previous_entry_proprietary = entry.proprietary

      output_file_name = (os.path.splitext(os.path.basename(str(entry.proprietary)))[0] + "_" + source_name + "_" + str(same_file_counter).zfill(max_numbers_places) + "_" + str(video_number).zfill(max_numbers_places) + ".mp4")

      output_file_path = os.path.join(new_output_directory, output_file_name)
   
      try:
         # saves video clip from buffered beginning to buffered end of the time frame of the subtitle timestamp
         # uses ffmpeg fast and accurate option and only uses the first video and audio streams to create the clip
         process = subprocess.run(['ffmpeg', '-loglevel', '-8', '-ss', '%s' % (str(entry.start)[:11]), '-i', '%s' % (str(entry.proprietary)), '-t', (str(entry.end-entry.start)[:11]), '-map', '0:v', '-map', '0:a', '%s' % (output_file_path)], shell=True)
      except:
         print("Error", flush=True)
      print(f"progress: {video_number}/{total_clips}", flush=True)
      video_number += 1 

def mergeMultipleClips(subtitle_source, output_directory, buffer_seconds_start, buffer_seconds_end):
      """
      Saves all entries in a searched subtitle file into a single .mp4 file.\n
      subtitle_source must be a subtitle file generated by find_subtitle_matches_single or find_subtitle_matches_batch functions.\n
      buffer_seconds_start and buffer_seconds_end are buffers of time added to extend clip before and after subtitle entry time frame.
      """
      video_number = 1

      source_name = os.path.splitext(os.path.basename(subtitle_source))[0]

      # creates temporary file directory where individual video clips are saved before merging
      temp_dir = tempfile.mkdtemp()
      os.chdir(temp_dir)

      video_number = 1
      source_name = os.path.splitext(os.path.basename(subtitle_source))[0]

      # opens searched subtitle file and adds buffer to beginning and end of all entries
      # merges entry times together where overlap exists
      with open(subtitle_source, encoding='utf-8') as file:
         subtitle_generator = srt.parse(file)

         subtitles_list = list(subtitle_generator)
         buffer_start_datetime = datetime.timedelta(seconds=buffer_seconds_start)
         buffer_end_datetime = datetime.timedelta(seconds=buffer_seconds_end)

         # stops addition of buffer from extending clip beyond beginning of the source video file
         for entry in subtitles_list:
            if(entry.start > buffer_start_datetime):
               entry.start = entry.start - buffer_start_datetime
            else:
               entry.start -= entry.start
            entry.end = entry.end + buffer_end_datetime

      entry_index = 0
      # merges entry times together where overlap exists
      # extends the first and deletes the second entries of the merge
      while(entry_index < len(subtitles_list)-1):
         if(subtitles_list[entry_index].proprietary == subtitles_list[entry_index+1].proprietary):
            if(subtitles_list[entry_index].end >= subtitles_list[entry_index+1].start):
               subtitles_list[entry_index].end = subtitles_list[entry_index+1].end
               del subtitles_list[entry_index+1]
            else:
               entry_index += 1
         else:
            entry_index += 1
      total_clips = len(subtitles_list)

      max_numbers_places = int(math.log10(total_clips))+1
      video_number = 1
      for entry in subtitles_list:
         # spaces must be replaced with dashes so ffmpeg can read video clip file paths from text file
         output_file_name = str(source_name + "_" + str(video_number).zfill(max_numbers_places) + ".mp4").replace(' ', '_')
         try:
            # saves video clip from buffered beginning to buffered end of the time frame of the subtitle timestamp
            # uses ffmpeg fast and accurate option and only uses the first video and audio streams to create the clip
            process = subprocess.run(['ffmpeg', '-loglevel', 'error', '-ss', '%s' % (str(entry.start)[:11]), '-i', '%s' % (str(entry.proprietary)), '-to', (str(entry.end-entry.start)[:11]), '-map', '0:v', '-map', '0:a', '%s' % (output_file_name)])
         except:
            print("Error", flush=True)
         print(f"progress: {video_number}/{total_clips}", flush=True)
         video_number += 1

      os.chdir(temp_dir)
      file_list = os.listdir(temp_dir)

      temp_video_list_file = open('temp_video_list_file.txt', "w")

      for file in file_list:
         # records video clip paths into text file. this file is used in final merge
         temp_video_list_file.write('file ' + str(os.path.splitdrive(os.path.join(str(os.path.abspath(temp_dir)), str(file)))[1]).replace('\\', '/').replace(' ', '_') + '\n')

      temp_video_list_file.close()

      input_path_string = str(os.path.join(str(os.path.abspath(temp_dir)), 'temp_video_list_file.txt'))
      output_path_string = str(os.path.join(str(os.path.abspath(output_directory)), source_name) + ".mp4")
      
      duplicate_count = 0
      while(os.path.isfile(output_path_string)):
         duplicate_count +=1 
         output_path_string = str(os.path.join(str(os.path.abspath(output_directory)), source_name + "(" + str(duplicate_count) + ")") + ".mp4")
      try:
         # joins together individual clips into a single file .mp4 file
         process = subprocess.run(['ffmpeg', '-loglevel', '-8', '-f', 'concat', '-safe', '0', '-i', '%s' % (input_path_string), '-c', 'copy', '%s' % (output_path_string)], shell=True)
      except:
         print("Error", flush=True)